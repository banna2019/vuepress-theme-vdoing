---
title: 运算符
date: 2022-10-27 22:14:17
permalink: /pages/5ea2ec/
categories:
  - Golang
  - 基础
  - 数据类型与运算符
tags:
  - 
author: 
  name: Bruce
  link: https://github.com/banna2019
---
#### 一、运算符

>算术运算符 / 赋值运算符 / 比较运算符 / 逻辑运算符 / 位运算符 / 位移运算符 / 运算符的优先级

##### 1.1  语法

表达式：(a + b) * c

​	a,b,c叫做操作数

​	+,*,叫做运算符



##### 1.2  算术运算符

```shell
+ - * / %(求余) ++ --
```



###### 算数运算符demo

```go
package main

import "fmt"

func main() {
	/*
		算数运算符: +,-,*,/,%,++,--
		+
		-
		*,乘法
		/: 取商,两个数相除,取商
		%: 取余,取模 两个数相除,取余数

		++: 给自己+1(针对于整数)
		--: 给自己-1(针对于整数)
	*/
	a := 10
	b := 3
	sum := a + b
	fmt.Printf("%d + %d = %d\n", a, b, sum)

	sub := a - b
	fmt.Printf("%d - %d = %d\n", a, b, sub)

	mul := a * b
	fmt.Printf("%d * %d = %d\n", a, b, mul)

	div := a / b //取商
	mod := a % b //取余
	fmt.Printf("%d / %d = %d\n", a, b, div)
	fmt.Printf("%d %% %d = %d\n", a, b, mod)

	c := 3
	c++ // 给c + 1
	fmt.Println(c)

	c-- //给c - 1
	fmt.Println(c)
}
```





##### 1.3 关系运算符

```go
== != > < >= <=
```

###### 关系运算符demo

```go
package main

import "fmt"

func main() {
	/*
			关系运算符: >,<,>=,<=,==,!=
				结果总是bool类型的: true,false
				==: 表示比较两个数值是相等的
		 	 	!=: 表示比较两个数值是不相等的
	*/

	a := 3
	b := 5
	c := 3
	res1 := a > b
	res2 := b > c
	fmt.Printf("%T,%t\n", res1, res1)
	fmt.Printf("%T,%t\n", res2, res2)

	res3 := a == b
	res4 := a == c
	fmt.Printf("%T,%t\n", res3, res3)
	fmt.Printf("%T,%t\n", res4, res4)

	fmt.Println(a != b, a != c)
}
```



##### 1.4 逻辑运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| &&     | 所谓逻辑与运算符.如果两个操作数都非零,则条件变为真           |
| \|\|   | 所谓的逻辑或操作.如果任何两个操作数是非零,则条件变为真       |
| !      | 所谓逻辑非运算符.使用反转操作数的逻辑状态.如果条件为真,那么逻辑非操后结果为假 |

###### 逻辑运算符demo

```go
package main

import "fmt"

func main() {
	/*
			逻辑运算符: 操作数必须是bool,运算结果也是bool
			逻辑与: &&(go中的逻辑与属于短路与)
				运算规则:所有的操作数都是真,结果才为真,有一个为假,结果为假
						"一假则假,全真为真"
			逻辑或: ||
				运算规则:偶有的操作数是假,结果才为假,有一个为真,结果为真
					"一真为真,全假为假"
			逻辑非: !
				!T -> false
				!F -> true

		与: &(把所有的与运算都计算一遍)
		短路与: &&(在从左往右计算的时候,遇到一个false则直接返回false)
		或: | (所有操作数都需要操作计算才得出结果)
		短路或: ||(在从左往右计算的时候,遇到一个true则直接返回true)
	*/
	f1 := true
	f2 := false
	f3 := true
	res1 := f1 && f2
	fmt.Printf("res1: %t\n", res1)

	res2 := f1 && f2 && f3
	fmt.Printf("res2: %t\n", res2)

	res4 := f1 || f2 || f3
	fmt.Printf("res4: %t\n", res4)
	fmt.Println(false || false || false)

	fmt.Printf("f1: %t,!f1:%t\n", f1, !f1)
	fmt.Printf("f2: %t,!f2:%t\n", f2, !f2)

	a := 3
	b := 2
	c := 5
	res5 := a > b && c%a == b && a < (c/b)
	fmt.Println(res5)
	//fmt.Println(a > b && c%a == b)
	//fmt.Println(a < (c / b))

	res6 := b*2 < c || a/b != 0 || c/a > b
	fmt.Println(res6)

	res7 := !(c/a == b)
	fmt.Println(res7)
}

```



##### 1.5 位运算符

| A    | B    | A&B  | A\|B | A^B  |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    |
| 0    | 1    | 0    | 1    | 1    |
| 1    | 1    | 1    | 1    | 0    |
| 1    | 0    | 0    | 1    | 1    |

这里最难理解的就是`^`了,只要认为`AB`两者都相同的时候,为`0`,其他都为`1`

假设A为60,B为13

| 运算 | 描述                                                         | 示例                            |
| ---- | ------------------------------------------------------------ | ------------------------------- |
| &    | 二进制与操作副本位的结果,如果它存在于两个操作数              | (A & B) = 12, 也就是 0000 1100  |
| \|   | 二进制或操作副本,如果它存在一个操作数                        | (A \| B) = 61, 也就是 0011 1101 |
| ^    | 二进制异或操作副本,如果它被设置在一个操作数就是按位取非      | (A ^ B) = 49, 也就是 0011 0001  |
| &^   | 二进制位清空&^                                               | (A&^B)=48,也就是110000          |
| <<   | 二进制左移位运算符.左边的操作数的值向左移动由右操作数指定的位数 | A << 2 =240 也就是 1111 0000    |
| >>   | 二进制向右移位运算符.左边的操作数的值由右操作数指定的位数向右移动 | A >> 2 = 15 也就是 0000 1111    |



###### 二进制转十进制计算公式

![image-20220810232848308](https://bruce-log-img.oss-cn-shanghai.aliyuncs.com/image-20220810232848308.png)



###### 位运算demo

```go
package main

import "fmt"

func main() {
	/*
		位运算符:
			将数值,转为二进制后,按位操作
		按位&:
			对应位的值如果为1才为1,有一个为0就为0
		按位|:
			对应位的值如果都是0才为0,有一个为1就为1
		异或^:
			二元: a^b
				对应位的值不同为1,相同为0
			一元: ^a
				按位取反:
					 1 --->0
					 0 --->1
		位清空: &^
			对于 a &^ b
				对于b上的每个数值
					如果为0,则取a对应位上的数值
					如果为1,则结果位就取0
		位移运算符:
			<<: 按位左移,将a转为二进制,向左移动b位
				a << b
			>>: 按位右移,将a转为二进制,向右移动b位
				a >> b

		二进制数转十进制手动计算:
			从0到高位以2的次幂相加计算得出的数,才为二进制相对应的十进制数值
	*/

	a := 60 // 0011 1100
	b := 13 // 0000 1101
	/*
			a: 60, 0011 1100
			b: 13, 0000 1101
			&      0000 1100  	//
			|      0011 1101
			^      0011 0001
			&^     0011 0000

			异或^:(一元计算,按位取反)
			a: 0000 0000 .... 0011 1100
		       1111 1111 .... 1100 0011
	*/

	fmt.Printf("a:%d,%b\n", a, a)
	fmt.Printf("a:%d,%b\n", b, b)

	res1 := a & b // 12
	fmt.Println(res1)

	res2 := a | b // 61
	fmt.Println(res2)

	res3 := a ^ b // 49
	fmt.Println(res3)

	res4 := a &^ b // 48
	fmt.Println(res4)

	res5 := ^a // -61
	fmt.Println(res5)

	c := 8
	/*
			c : .... 0000 1000
		      .... 0000 100000
				       0000 10
	*/
	res6 := c << 2 // 32
	fmt.Println(res6)

	res7 := c >> 2 // 2
	fmt.Println(res7)
}

```





##### 1.6 赋值运算符

| 运算符 | 描述                                                         | 示例                         |
| ------ | ------------------------------------------------------------ | ---------------------------- |
| =      | 简单的赋值操作符,分配值从右边的操作数左侧的操作数            | C = A + B 将分配A + B的值到C |
| +=     | 相加并赋值运算符,它增加了右操作数左操作数和分配结果左操作数  | C += A 相当于 C = C + A      |
| -=     | 减和赋值运算符,它减去右操作数从左侧的操作数和分配结果左操作数 | C -= A 相当于 C = C - A      |
| *=     | 乘法和赋值运算符,它乘以右边的操作数与左操作数和分配结果左操作数 | C *= A 相当于 C = C * A      |
| /=     | 除法赋值运算符,它把左操作数与右操作数和分配结果左操作数      | C /= A 相当于 C = C / A      |
| %=     | 模量和赋值运算符,它需要使用两个操作数的模量和分配结果左操作数 | C %= A 相当于 C = C % A      |
| <<=    | 左移位并赋值运算符                                           | C <<= 2 相同于 C = C << 2    |
| >>=    | 向右移位并赋值运算符                                         | C >>= 2 相同于 C = C >> 2    |
| &=     | 按位与赋值运算符                                             | C &= 2 相同于 C = C & 2      |
| ^=     | 按位异或并赋值运算符                                         | C ^= 2 相同于 C = C ^ 2      |
| \|=    | 按位或并赋值运算符                                           | C \|= 2 相同于 C = C \| 2    |



###### 赋值运算demo

```go
package main

import "fmt"

func main() {
	/*
		赋值运算
			=,+=,-=,*=,/=,%=,,<<=,>>=,&=,|=,^=.....
			=,把=右侧的数值,赋值给=左边的变量

			+=, a += b,相当于a = a + b
				a++, a += 1
	*/

	var a int
	a = 3
	fmt.Println(a)

	a += 4
	fmt.Println(a)

	a -= 3
	fmt.Println(a)
	a *= 2
	fmt.Println(a)
	a /= 3
	fmt.Println(a)
	a %= 1
	fmt.Println(a)
}
```



##### 1.7  优先级运算符优先级

有些运算符拥有较高的优先级,二元运算符的运算方向均是从左至右.下表列出了所有运算符以及它们的优先级,由上至下代表优先级由高到低：

| 优先级 | 运算符           |
| ------ | ---------------- |
| 7      | ~ ! ++ --        |
| 6      | * / % << >> & &^ |
| 5      | + -  ^           |
| 4      | == != < <= >= >  |
| 3      | <-               |
| 2      | &&               |
| 1      | \|\|             |

当然,可以通过使用括号来临时提升某个表达式的整体运算优先级.













